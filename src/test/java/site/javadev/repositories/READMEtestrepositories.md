# Общее объяснение работы класса RepositoriesTest
Инициализация тестов:
Аннотация @DataJpaTest запускает Spring Boot в урезанном режиме, включая только компоненты JPA (репозитории, Hibernate).
H2 создаёт временную базу данных в памяти (см. spring.datasource.url=jdbc:h2:mem:testdb в application.properties для тестов).
Перед запуском тестов Hibernate автоматически создаёт таблицы (book, person, person_security) на основе моделей (Book, Person, PersonSecurity).
Транзакции:
Каждый тест выполняется в отдельной транзакции. После завершения теста транзакция откатывается, что очищает базу данных для следующего теста.
Это означает, что тесты изолированы друг от друга — данные из одного теста не влияют на другой.
Пошаговый процесс теста:
Создание данных: Создаём объект (например, Book, PersonSecurity, Person) и заполняем его поля.
Действие: Вызываем метод репозитория (например, save, findById, deleteById).
Проверка: Используем assertNotNull, assertEquals, assertTrue, assertFalse из JUnit для проверки результатов.
Особенности работы с репозиториями:
Репозитории (BookRepository, PeopleRepository, PersonRepository) наследуются от JpaRepository, что даёт им стандартные методы (save, findById, findAll, deleteById).
PeopleRepository имеет дополнительный метод findByUsername, который мы тоже тестируем.
Почему это работает
Ты заменил year на publicationYear в модели Book, что устранило конфликт с зарезервированным словом в H2.
Тесты используют H2 в памяти, что быстро и не требует внешней базы данных.
Каждый тест проверяет один конкретный метод репозитория, что делает их независимыми и понятными.